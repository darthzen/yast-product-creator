/**
 * File:	modules/Kiwi.ycp
 * Package:	Configuration of product-creator
 * Summary:	Data for kiwi configuration, input and output functions.
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
  module "Kiwi";

  textdomain "product-creator";

  import "Directory";
  import "FileUtils";
  import "Label";
  import "Message";
  import "Package";
  import "Popup";
  import "Progress";
  import "Report";
  import "Security";
  import "String";
  import "URL";

  string encryption_method	= nil;

  // temporary directory, where kiwi is working
  global string tmp_dir	= "";

  // directory for saving image configurations
  global string images_dir	= Directory::vardir + "/product-creator/images";

  // bug 331733
  global string supported_boot_images	= "";

  // directories with user-made templated
  global list<string> templates_dirs	= [];

  global string default_packagemanager	= "zypper";

  list<map> all_sources		= [];

  // repositories used for current configuration
  global map <string,map> current_repositories	= $[];

  // initial system repositories
  global map <string,map> initial_repositories	= $[];

  // where the kiwi configuration files are stored
  string config_dir	= "";

  // chroot directory for creating the physical extend
  string chroot_dir	= "";

  // What we want to create with kiwi
  global string kiwi_task	= "iso";

  // map with image templates (to base new projects on)
  global map<string,map> Templates		= $[];

  /**
   * crypt given user password with current encryption algorithm
   */
  string crypt_password	(string pw)
  {
    if (pw == "") return pw;
    if (encryption_method == nil)
    {
	boolean progress = Progress::set (false);
	Security::Read ();
	Progress::set (progress);
	map security	= Security::Export ();
	encryption_method  = tolower (security["PASSWD_ENCRYPTION"]:"des");
    }
    if (encryption_method == "md5")
	return cryptmd5 (pw);
    if (encryption_method == "blowfish")
	return cryptblowfish (pw);
    return crypt (pw);
  }

  /**
   * change the yast source path format to kiwi (smart?) one
   */
  string adapt_source_path (string source) {

    if (substring (source, 0, 6) == "dir://")
	return substring (source, 6);
    return source;
  }

  /**
   * generate the 'repository' tag
   */
  map get_source_value (string source, map config) {

    map ret	= $[];
    // first check if we weren't importing this source:
    foreach (string url, map repo, current_repositories, {
	if (url == source && repo["org"]:$[] != $[])
	{
	    ret = $[
		"__key"	: "repository",
		"type"	: repo["org","type"]:"",
		"__children": [
		    $[
			"__key"	: "source",
			"path"	: repo["org","source",0,"path"]:"",
		    ]
		]
	    ];
	    if (repo["org","status"]:"" != "")
		ret["status"]	= repo["org","status"]:"";
	}
    });
    if (ret != $[])
    {
	y2milestone ("imported source: %1", source);
	return ret;
    }

    // ... otherwise, we must ask zypp:
    string type		= "yast2";

    foreach (map sourcemap, all_sources, {
	integer srcid	= sourcemap["SrcId"]:-1;
        map data	= Pkg::SourceGeneralData (srcid);
	string url	= data["url"]:"";
	if (url == source || url == adapt_source_path (source))
	{
	    if (data["type"]:"" == "Plaindir")
		type	= "rpm-dir";
	    if (data["type"]:"" == "YUM")
		type	= "rpm-md";
	    map parsed = URL::Parse(url);
	    if (parsed["scheme"]:"" == "https")
	    {
		// change source url to contain password
		source      = Pkg::SourceURL (srcid);
	    }
	}
    });
    ret = $[
	"__key"	: "repository",
	"type"	: type,
	"__children": [
	    $[
		"__key"	: "source",
		"path"	: adapt_source_path (source)
	    ]
	]
    ];
    return ret;
  }

  /**
   * generate the name of directory with kiwi configuration
   */
  string get_config_dir (string name, string task) {
    return deletechars (name, " \t");
  }


  /**
   * generate the values for image type
   */
  list<map> get_type_values (map config, string task) {

    string boot_image	= sformat ("%1boot/%2", task, config[task + "boot"]:"suse-10.2");
    list<map> retlist = maplist (
	string type, map typemap, (map<string,map>)config["type"]:$[], {

	if (typemap["boot"]:"" != "")
	    boot_image	= typemap["boot"]:"";

	map ret	= $[
	    "__key"		: "type",
	    "__value"		: type,
	    "boot"		: boot_image,
	];
	if (type != "iso")
	    ret["filesystem"]	= typemap["filesystem"]:"ext3";
	if (typemap["flags"]:"" != "")
	    ret["flags"]            = typemap["flags"]:"";
	if (typemap["format"]:"" != "")
	    ret["format"]           = typemap["format"]:"";
	if (type == "vmx" && ret["format"]:"" == "")
	    ret["format"]		= "vmdk";
	if (type == task)
	    ret["primary"]	= "true";
	return ret;
    });
    // create default values for new project
    if (retlist == [])
    {
	map ret	= $[
	    "__key"		: "type",
	    "__value"		: task,
	    "boot"		: boot_image,
	    "primary"		: "true"
	];
	if (task != "iso")
	    ret["filesystem"]	= "ext3";
	if (task == "vmx")
	    ret["format"]	= "vmdk";
	if (task == "iso" || task == "oem")
	    ret["flags"]	= "unified";
	retlist	= [ ret ];
    }
    return retlist;
  }

  /**
   * generate the value map for group to be used by Map2XML
   */
  map get_group_value (string group, list<map> userlist) {

    string gid	= "";
    map ret	= $[
	"__key"	: "users",
	"group"	: group,
	"__children" : maplist (map usermap, userlist, {
	    map u	= $[
		"__key"	: "user",
		"name"	: usermap["username"]:"",
		"pwd"	: (usermap["encrypted"]:false) ?
			    usermap["pwd"]:"" :
			    crypt_password (usermap["pwd"]:""),
		"home"	: usermap["home"]:"",
	    ];
	    if (usermap["realname"]:"" != "")
		u["realname"]	= usermap["realname"]:"";
	    if (usermap["id"]:"" != "")
		u["id"]	= usermap["id"]:"";
	    if (usermap["gid"]:"" != "")
		gid	= usermap["gid"]:"";
	    return u;
	})
    ];
    if (gid != "")
	ret["id"]	= gid;
    return ret;
  }

  /**
   * which keys in config.xml are not unique
   */
  map non_unique_key	= $[
    "package"		: true,
    "opensusePattern"	: true,
    "ignore"		: true,
    "user"		: true,
    "source"		: true,
    "file"		: true, // for drivers section
    "profile"		: true,
  ];

  /**
   * convert YCP map (of internal type) to XML
   */
  string Map2XML (map descr, integer level) {

    string children	= "";
    string value	= "";
    string tab		= "";
    integer i		= 0;
    while (i < level) {
	i = i + 1;
	tab	= tab + "  ";
    }
    string key	= descr["__key"]:"";
    if (key == "") return "";
    string ret	= tab + "<" + key;
    foreach (string subkey, any val, (map<string,any>) descr, {
	if (subkey == "__key" || non_unique_key[subkey]:false) return;
	if (subkey == "__children" && is (val, list))
	    foreach (map chmap, (list<map>) val, {
		children	= children + "\n" + Map2XML (chmap, level + 1);
	    });
	else if (subkey == "__value")
	    value = String::EscapeTags (sformat ("%1", val));
	else if (is (val, string) || is (val, integer))
	    ret	= sformat ("%1 %2=\"%3\"",
		ret, subkey, String::EscapeTags (tostring (val)));
    });
    if (non_unique_key[key]:false)
	return sformat ("%1/>", ret);
    if (value != "")
	ret = sformat ("%1>%2", ret, value);
    else
	ret	= ret + ">";
    if (children != "")
	ret =	 ret + children + "\n";

    if (level == 0 && key == "image") // ugly hack
	return ret;
    ret	= sformat ("%1%2</%3>", ret, haskey (descr, "__value") ? "" : tab, key);
    return ret;
  }

  // argument for any_xml agent: key indicating content of element without
  // attributes
  string content_key	= "__yast_content__";

  /**
   * convert YCP map (of type read from any_xml agent) to XML
   */
  string MapAny2XML (string item_key, map item_descr, integer level) {

    string tab		= "";
    integer i		= 0;
    while (i < level) {
	i = i + 1;
	tab	= tab + "  ";
    }
    string ret		= tab + "<" + item_key;
    string attr		= "";
    string subret	= "";
    string content	= "";
    foreach (string key, any value, (map<string,any>) item_descr, {

	if (is (value, list))
	{
	    foreach (map it_map, (list<map>) value, {
		subret	= subret + "\n" + MapAny2XML (key, it_map, level + 1);
	    });
	}
	else if (is (value,string) || is (value,integer) || is (value,boolean))
	{
	    if (key == content_key)
		content	= String::EscapeTags (tostring (value));
	    else
		attr = attr + sformat (" %1=\"%2\"",
		    key, String::EscapeTags (tostring (value))
		);
	}
    });
    ret	= ret + attr;
    ret	= ret + ((subret == "" && content == "")? "/>" : ">");
    if (content != "")
	ret	= ret + content + sformat ("</%1>", item_key);
    else if (subret != "")
	ret	= ret + subret + "\n" + tab + sformat ("</%1>", item_key);
    return ret;
  }

  /**
   * import the data from given config.xml
   * @param directory where to look for config.xml
   * @ret map of imported data
   */
  global map<string,any> ReadConfigXML (string base_path) {

    map<string,any> ret	= $[];
    if (!FileUtils::Exists (base_path + "/config.xml"))
	return ret;

    map config	= (map) SCR::Read (.kiwi, base_path + "/config.xml");
    if (config == nil)
	return ret;
    map<string,map> packages	= config["packages"]:$[];

    foreach (string key, [ "author", "contact", "image_type", "specification",
	"packagemanager", "version", "rpm-check-signatures", "rpm-force",
	"sizeunit", "type", "name", "repository", "defaultdestination",
	"schemeversion", "defaultroot", "inherit", "locale", "timezone",
	"keytable"],
    {
	if (config[key]:nil != nil)
	    ret[key]	= config[key]:nil;
    });
    if (haskey (config, "size"))
	ret["size"]	= tointeger (config["size"]:"2700");
    if (haskey (config, "defaultdestination"))
	ret["iso-directory"]	= config["defaultdestination"]:"";
    foreach (string user, map usermap, (map<string,map>) config["users"]:$[], {
	if (!haskey (ret, "users"))
	    ret["users"]     = $[];
	any pwd	= usermap["pwd"]:nil;
	boolean crypted	= (pwd != nil);
	ret["users",user]     = $[
	    "home"	: usermap["home"]:sformat ("/home/%1", user),
	    "pwd"	: (pwd == nil) ? user : pwd,
	    "encrypted"	: crypted,
	    "group"	: usermap["group"]:"",
	    "username"	: user,
	    "id"	: sformat ("%1", usermap["id"]:""),
	    "gid"	: sformat ("%1", usermap["gid"]:""),
	];
	if (usermap["realname"]:"" != "")
	    ret["users",user,"realname"]	= usermap["realname"]:"";
    });

    map anyxml		= (map) SCR::Read (.anyxml, base_path + "/config.xml");
    map image		= anyxml["image",0]:$[];
    ret["packages"]	= image["packages"]:[];
    ret["profiles"]	= image["profiles"]:[];
    ret["split"]	= image["split"]:[];
    return ret;
  }

  /**
   * Write currect configuration to new config.xml
   */
  global boolean WriteConfigXML (map KiwiConfig, string task) {

    all_sources		= Pkg::SourceEditGet();

    tmp_dir		= Directory::tmpdir;
    chroot_dir		= tmp_dir + "/myphysical";
    if (KiwiConfig["defaultroot"]:"" != "")
    {
	chroot_dir	= KiwiConfig["defaultroot"]:"";
	if (KiwiConfig["new_configuration"]:false)
	    chroot_dir	= chroot_dir + "/" + KiwiConfig["name"]:"";
	KiwiConfig["defaultroot"]	= chroot_dir;
    }

    // for the order of keys in preferences section, see bug 355568
    map preferences	= $[
	    "__key"	: "preferences",
	    "__children"	: [
		$[
		    "__key"	: "version",
		    "__value"	: KiwiConfig["version"]:"1",
		],
		$[
		    "__key"	: "size",
		    "unit"	: KiwiConfig["sizeunit"]:"M",
		    "__value"	: sformat ("%1", KiwiConfig["size"]:2700),
		],
		$[
		    "__key"	: "packagemanager",
		    "__value"   : KiwiConfig["packagemanager"]:default_packagemanager
		],
		$[
		    "__key"	: "rpm-check-signatures",
		    "__value"	: KiwiConfig["rpm-check-signatures"]:"False",
		],
		$[
		    "__key"	: "rpm-force",
		    "__value"	: KiwiConfig["rpm-force"]:"True",
		],
	    ],
    ];
    // "type" goes to the first place
    foreach (map typemap, get_type_values (KiwiConfig, task), {
	preferences["__children"]	= prepend (preferences["__children"]:[],
	    typemap);
    });
    // iso-directory is the correct value, it could have been altered via UI
    KiwiConfig["defaultdestination"]	= KiwiConfig["iso-directory"]:"";
    foreach (string key, [ "keytable", "timezone", "locale",
	"defaultdestination", "defaultroot" ],
    {
	if (KiwiConfig[key]:"" != "")
	{
	    preferences["__children"]	= add (preferences["__children"]:[], $[
		"__key"		: key,
		"__value"	: KiwiConfig[key]:"",
	    ]);
	}
    });

    list write_list	= [ $[
      "__key"		: "image",
      "name"		: KiwiConfig["name"]:"",
      "schemeversion"	: KiwiConfig["schemeversion"]:"1.4",
      "__children"	: [
	$[
	    "__key"	: "description",
	    "type"	: "system",
	    "__children"	: [
		$[
		    "__key"	: "author",
		    "__value"	: KiwiConfig["author"]:"",
		],
		$[
		    "__key"	: "contact",
		    "__value"	: KiwiConfig["contact"]:"",
		],
		$[
		    "__key"	: "specification",
		    "__value"	: KiwiConfig["specification"]:"",
		],
	    ],
	],
	preferences,
      ],
    ]];
    if (KiwiConfig["inherit"]:"" != "")
	write_list[0,"inherit"]	= KiwiConfig["inherit"]:"";
    if (size (KiwiConfig["profiles"]:[]) > 0)
    {
	write_list[0,"__children"] = add (write_list[0,"__children"]:[], $[
	    "__key"     : "profiles",
	    "__children" : maplist (
		map profile, KiwiConfig["profiles",0,"profile"]:[], {
		    return union ($[ "__key"     : "profile"], profile);
		})
	]);
    }
    if (haskey (KiwiConfig, "users"))
    {
	map<string,list> groups2users	= $[];
	foreach (string user, map usermap,
	    (map<string,map>) KiwiConfig["users"]:$[],
	{
	    string g	= usermap["group"]:"";
	    if (g == "")
		g	= user == "root" ? "root" : "users";
	    if (!haskey (groups2users, g))
		groups2users[g]	= [];
	    groups2users[g]	= add (groups2users[g]:[], usermap);
	});
	foreach (string group, list userlist, groups2users, {
	    write_list[0,"__children"] = add (write_list[0,"__children"]:[],
		get_group_value (group, (list<map>) userlist)
	    );
	});
    }
    write_list[0,"__children"] = union (write_list[0,"__children"]:[],
	maplist (string source, (list<string>) KiwiConfig["sources"]:[],
	    ``(get_source_value (source, KiwiConfig))
	)
    );
    map image_packages		= $[];
    list<map> profiles_packages	= [];
    map bootstrap_packages	= $[];
    foreach (map packagemap, KiwiConfig["packages"]:[], {
	/* example of packagemap:
	$[
	    "opensusePattern"	: [
		$[ "name":"base" ],
		$[ "name":"x11" ]
	    ],
	    "package"	: [ $[ "name":"zypper" ] ],
	    "type"	: "image",
	    "profiles"	: "KDE"
	]*/
	map pmap	= union (packagemap, $[
	    "__key"     : "packages",
	]);
	string type	= pmap["type"]:"";
	pmap["__children"]     = maplist (map p, pmap["package"]:[], ``(
	    union (p, $[ "__key" : "package"]))
	);
	if (haskey (pmap, "package"))
	    pmap	= remove (pmap,"package");
	if (haskey (pmap, "ignore"))
	{
	    pmap["__children"]	= union (pmap["__children"]:[],
		maplist (map p, pmap["ignore"]:[], ``(
		    union (p, $[ "__key" : "ignore"]))
		)
	    );
	    pmap        = remove (pmap, "ignore");
	}
	if (haskey (pmap, "opensusePattern"))
	{
	    pmap["__children"]  = union (pmap["__children"]:[],
		maplist (map p, pmap["opensusePattern"]:[], ``(
		    union (p, $[ "__key" : "opensusePattern"]))
		)
	    );
	    pmap	= remove (pmap,"opensusePattern");
	}
	if (type == "bootstrap")
	    bootstrap_packages	= pmap;
	else if (type == "image" && pmap["profiles"]:"" == "")
	{
	    image_packages	= pmap;
	}
	else if (size (pmap["__children"]:[]) > 0)
	{
	    profiles_packages	= add (profiles_packages, pmap);
	}
    });
    if (image_packages != $[])
	write_list[0,"__children"] =
	    add (write_list[0,"__children"]:[], image_packages);
    if (profiles_packages != [])
	write_list[0,"__children"] =
	    union (write_list[0,"__children"]:[], profiles_packages);
    if (bootstrap_packages != $[])
	write_list[0,"__children"] =
	    add (write_list[0,"__children"]:[], bootstrap_packages);

    // generate the XML using current Map2XML function
    string write_string	= "<?xml version=\"1.0\"?>\n" +
	Map2XML (write_list[0]:$[], 0);

    // now, add the rest, created using more generic MapAny2XML function
    if (haskey (KiwiConfig, "split") && size (KiwiConfig["split"]:[]) > 0)
    {
	string split	= MapAny2XML ("split", KiwiConfig["split",0]:$[], 1);
	if (split != "")
	{
	    write_string = write_string + split + "\n";
	}
    }
    write_string	= write_string + "</image>";

    config_dir	= tmp_dir + "/" + KiwiConfig["name"]:"";
    SCR::Execute (.target.mkdir, config_dir);
    SCR::Write (.target.string, config_dir + "/config.xml", write_string);
    // config.xml may contain password
    SCR::Execute (.target.bash, sformat ("chmod 600 %1/config.xml",config_dir));
    foreach (string dir, ["root_dir", "config_dir"], {
	foreach (string val, KiwiConfig[dir]:[], {
	    string realdir	= config_dir + "/" + substring (dir, 0, search (dir, "_"));
	    boolean created	= false;
	    if (val != "" && FileUtils::Exists (val))
	    {
		if (!created && !FileUtils::Exists (realdir))
		{
		    SCR::Execute (.target.mkdir, realdir);
		    created	= true;
		}
		SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", val, realdir));
	    }
	});
    });
    foreach (string file, ["images.sh", "config.sh" ], {
	if (KiwiConfig[file]:"" != "")
	{
	    SCR::Write (.target.string, config_dir + "/" + file, KiwiConfig[file]:"");
	    SCR::Execute (.target.bash, "chmod +x " + config_dir + "/" + file);
	}
    });
    foreach (string file, KiwiConfig["import_files"]:[], {
	y2milestone ("copying %1 to %2", file,config_dir);
	SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", file,config_dir));
    });
    return true;
  }

  // run kiwi to finally create the live iso image
  global boolean PrepareAndCreate (string out_dir, string selected_profiles) {

    if (config_dir == "" || !FileUtils::Exists (config_dir))
	return false;
    if (!Package::Install ("kiwi"))
    {
	Report::Error (Message::CannotContinueWithoutPackagesInstalled ());
	return false;
    }

    if (FileUtils::Exists (chroot_dir))
    {
	y2milestone ("%1 directory is present, removing...", chroot_dir);
	SCR::Execute (.target.bash, sformat ("rm -rf %1", chroot_dir));
    }

    // construct the dialog
    UI::OpenDialog(`opt(`decorated), `HBox(`HSpacing(1.5),
    `VBox(
        `HSpacing(85),
	`VWeight (2, `VBox (
	    `VSpacing(0.5),
	    // label
	    `ReplacePoint (`id (`rpl), `Left (`Label(_("Preparing for Image Creation")))),
	    `VSpacing(0.5),
	    `LogView (`id (`log), "", 8, 0)
	)),
	`VWeight (1, `VBox (
	    `VSpacing(0.5),
	    `LogView (`id (`errlog), "", 8, 0),
	    `VSpacing(0.5),
	    `ReplacePoint (`id (`rp), `PushButton (`id(`cancel),`opt(`key_F9), Label::CancelButton ())),
	    `VSpacing(0.5)
	))
    ), `HSpacing(1.5)
    ));

    void update_output () {
        // read the output line from irw:
	list<string> out	= (list<string>)SCR::Read(.background.newout);
	foreach (string line, out, {
	    line	= String::Replace (line, "\r", "\n");
	    UI::ChangeWidget (`id(`log), `LastLine, line + "\n");
	});

	list<string> err = (list<string>) SCR::Read(.background.newerr);
	foreach (string line, err, {
	    line	= String::Replace (line, "\r", "\n");
	    UI::ChangeWidget (`id(`errlog), `LastLine, line + "\n");
	});
    }

    string cmd	= sformat ("ZYPP_READONLY_HACK=1 kiwi --nocolor --root %1 --prepare %2 --logfile terminal", chroot_dir, config_dir);
    if (selected_profiles != "" && selected_profiles != nil)
	cmd = cmd + selected_profiles;

    y2milestone ("calling '%1'", cmd);

    SCR::Execute (.background.run_output_err, cmd);

    symbol ret		= nil;
    boolean creating	= false;
    do
    {
	ret = (symbol) UI::PollInput();
        if ((boolean) SCR::Read(.background.output_open) &&
	    (integer) SCR::Read(.background.newlines)>0)
        {
	    update_output ();
        }
	else if (!(boolean)SCR::Read(.background.isrunning))
	{
	    update_output ();

	    integer status	= (integer) SCR::Read (.background.status);
	    if (status != 0)
	    {
		UI::ReplaceWidget (`id (`rp), `HBox (
		    // label (command result)
		    `Label (`opt (`boldFont), _("Image creation failed.")),
		    `PushButton (`id(`close), Label::CloseButton ())
		));
		ret	= (symbol) UI::UserInput ();
		break;
	    }
	    else if (!creating)
	    {
		creating	= true;
		SCR::Execute(.background.kill); // just to be sure...

		// now continue with creating
		UI::ChangeWidget (`id(`log), `LastLine, "\n");
		cmd	= sformat ("ZYPP_READONLY_HACK=1 kiwi --nocolor --create %1 -d %2 --logfile terminal", chroot_dir, out_dir);
		y2milestone ("calling '%1'", cmd);
		// label
		UI::ReplaceWidget (`id (`rpl), `Left (`Label (_("Creating Image"))));
		SCR::Execute (.background.run_output_err, cmd);
		ret	= nil;
		continue;
	    }
	    else
	    {
		UI::ReplaceWidget (`id (`rp), `HBox (
		    // label (command result)
		    `Label (`opt (`boldFont), _("Image creation succeeded.")),
		    `PushButton (`id(`ok), Label::OKButton ())
		));
		ret	= (symbol) UI::UserInput ();
		break;
	    }
	}
	if (ret == `cancel)
	{
	    SCR::Execute(.background.kill);
	}
	sleep (100);
    } while (ret == nil);

    SCR::Execute(.background.kill);
    UI::CloseDialog ();
    return ret == `ok;
  }

  /**
   * save the image configuration to the kiwi images directory
   */
  global string SaveConfiguration (map KiwiConfig, string task) {
    if (config_dir == "" || !FileUtils::Exists (config_dir))
	return nil;
    if (!FileUtils::Exists (images_dir))
	SCR::Execute (.target.mkdir, images_dir);
    SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", config_dir, images_dir));
    return (images_dir + "/" + KiwiConfig["name"]:"");
  }

    /**
     * Import repositories from given kiwi image configuration
     * @patam Config configuration map, as read from config.xml
     * @param dir path to directory containing this config.xml
     */
    global map <string,map> ImportImageRepositories (map Config, string dir) {

	current_repositories	= $[];
	foreach (map repo, (list<map>) Config["repository"]:[], {
	    string source	= repo["source",0,"path"]:"";
	    if (source != "")
	    {
		string url	= "";
		if (substring (source, 0, 7) == "this://")
		{
		    string source_path = substring (source, 7);
		    source	= dir + "/" + source_path;
		}
		if (substring (source, 0, 1) == "/")
		    url	= "dir://";
		url	= url + source;
		map parsed      = URL::Parse (url);
		string full_url	= url;
		if (parsed["pass"]:"" != "")
		{
		    parsed      = remove (parsed, "pass");
		    url         = URL::Build (parsed);
		}
		current_repositories	[url]	= $[
		    "url"	: url,
		    "plaindir"	: repo["type"]:"" == "rpm-dir",
		    "org"	: repo,
		    "full_url"	: full_url
		];
	    }
	});
	return current_repositories;
    }

   /**
    * Initialize the list of current repositories
    */
   global map <string,map> InitCurrentRepositories () {

	Pkg::SourceRestore ();
	foreach (map source, Pkg::SourceEditGet (), {
	    integer srcid       = source["SrcId"]:-1;
	    map data = Pkg::SourceGeneralData (srcid);
	    string url	= data["url"]:"";
	    string full_url	= url;
	    map parsed = URL::Parse(url);
	    if (parsed["scheme"]:"" == "https")
		full_url	= Pkg::SourceURL (srcid);
	    current_repositories[url]	= $[
		"url"		: url,
		"plaindir"	: data["type"]:"" == "Plaindir",
		"full_url"	: full_url,
	    ];
	});
	return current_repositories;
   }

  /**
   * Read the templates on which the images can be based
   */
  global boolean ReadImageTemplates () {

    string dirs = (string)SCR::Read(.sysconfig.product-creator.IMAGE_TEMPLATES);
    map name_version	= $[];
    foreach (string line, splitstring (dirs, "\t "), {
	if (line == "" || substring (line, 0, 1) == "#")
	    return;
	templates_dirs	= add (templates_dirs, line);
	if (!FileUtils::IsDirectory (line))
	{
	    y2warning ("%1 is not a directory", line);
	    return;
	}
	map out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1", line));
	foreach (string d, splitstring(out["stdout"]:"", "\n"), {
	    if (d == "") return;
	    map config	= Kiwi::ReadConfigXML (line + "/" + d);
	    // index by full path, there may be same names
	    // (templates could be provided by different vendors)
	    if (config != nil && config != $[])
	    {
		string name	= config["name"]:"";
		string ver	= config["version"]:"";
		if (config["image_type"]:"" != "system")
		    y2warning ("%1 not a 'system' image type, skipping", name);
		else if (name_version[name]:"" == ver)
		    y2warning ("template %1,%2 already imported", name, ver);
		else
		{
		    name_version[name]	= ver;
		    Templates[line + "/" + d]	= config;
		}
	    }
	});
    });
    return true;
  }

  /**
   * REad the confgiuration stuff for image creator
   */
  global boolean Read () {

    string dir =
	(string) SCR::Read (.sysconfig.product-creator.IMAGE_CONFIGURATIONS);
    if (dir != nil && dir != "")
	images_dir	= dir;
    supported_boot_images	=
	(string) SCR::Read (.sysconfig.product-creator.SUPPORTED_BOOT_IMAGES);
    if (supported_boot_images == nil)
	supported_boot_images	= "";
    return ReadImageTemplates ();
  }
}

