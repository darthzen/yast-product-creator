/**
 * File:	modules/Kiwi.ycp
 * Package:	Configuration of product-creator
 * Summary:	Data for kiwi configuration, input and output functions.
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
  module "Kiwi";

  textdomain "product-creator";

  import "Directory";
  import "FileUtils";
  import "Label";
  import "Message";
  import "Package";
  import "Popup";
  import "Progress";
  import "Report";
  import "Security";
  import "String";

  string encryption_method	= nil;

  // temporary directory, where kiwi is working
  global string tmp_dir	= "";

  // directory for saving image configurations
  global string images_dir	= Directory::vardir + "/product-creator/images";

  // bug 331733
  global string supported_boot_images	= "";

  // directories with user-made templated
  global list<string> templates_dirs	= [];

  global string default_packagemanager	= "zypper";

  list<map> all_sources		= [];

  // repositories used for current configuration
  global map <integer,map> current_repositories	= $[];

  // initial system repositories
  global map <integer,map> initial_repositories	= $[];

  // where the kiwi configuration files are stored
  string config_dir	= "";

  // chroot directory for creating the physical extend
  string chroot_dir	= "";

  // What we want to create with kiwi
  global string kiwi_task	= "iso";

  // map with image templates (to base new projects on)
  global map<string,map> Templates		= $[];

  /**
   * crypt given user password with current encryption algorithm
   */
  string crypt_password	(string pw)
  {
    if (encryption_method == nil)
    {
	boolean progress = Progress::set (false);
	Security::Read ();
	Progress::set (progress);
	map security	= Security::Export ();
	encryption_method  = tolower (security["PASSWD_ENCRYPTION"]:"des");
    }
    if (encryption_method == "md5")
	return cryptmd5 (pw);
    if (encryption_method == "blowfish")
	return cryptblowfish (pw);
    return crypt (pw);
  }

  /**
   * change the yast source path format to kiwi (smart?) one
   */
  string adapt_source_path (string source) {

    if (substring (source, 0, 6) == "dir://")
	return substring (source, 6);
    return source;
  }

  /**
   * generate the 'repository' tag
   */
  map get_source_value (string source, map config) {

    map ret	= $[];
    // first check if we weren't importing this source:
    foreach (integer id, map repo, current_repositories, {
	if (repo["url"]:"" == source && repo["org"]:$[] != $[])
	{
	    ret = $[
		"__key"	: "repository",
		"type"	: repo["org","type"]:"",
		"__children": [
		    $[
			"__key"	: "source",
			"path"	: repo["org","source",0,"path"]:"",
		    ]
		]
	    ];
	    if (repo["org","status"]:"" != "")
		ret["status"]	= repo["org","status"]:"";
	}
    });
    if (ret != $[])
    {
	y2milestone ("imported source: %1", source);
	return ret;
    }

    // ... otherwise, we must ask zypp:
    string type		= "yast2";
    string source_path	= adapt_source_path (source);

    foreach (map sourcemap, all_sources, {
	integer srcid	= sourcemap["SrcId"]:-1;
        map data	= Pkg::SourceGeneralData (srcid);
	string url	= data["url"]:"";
	if (url == source || url == source_path)
	{
	    if (data["type"]:"" == "Plaindir")
		type	= "rpm-dir";
	    if (data["type"]:"" == "YUM")
		type	= "rpm-md";
	}
    });
    ret = $[
	"__key"	: "repository",
	"type"	: type,
	"__children": [
	    $[
		"__key"	: "source",
		"path"	: source_path
	    ]
	]
    ];
    return ret;
  }

  /**
   * generate the name of directory with kiwi configuration
   */
  string get_config_dir (string name, string task) {
    return deletechars (name, " \t");
  }

  /**
   * generate the value for image type
   */
  map get_type_value (map config, string task) {

    string boot_image	= sformat ("%1boot/%2", task, config[task + "boot"]:"suse-10.2");
    if (config["type",task,"boot"]:"" != "")
	boot_image	= config["type",task,"boot"]:"";
    map ret	= $[
	"__key"		: "type",
	"__value"	: task,
	"primary"	: "true",
	"boot"		: boot_image,
    ];
    if (task != "iso")
	ret["filesystem"]	= config["type",task,"filesystem"]:"ext3";
    if (config["type",task,"flags"]:"" != "")
	ret["flags"]            = config["type",task,"flags"]:"";
    return ret;
  }

  /**
   * generate the list of packages/patterns for image
   */
  map get_image_packages (map config, list packages, list patterns,list ignored)
  {
    map ret	= $[
	    "__key"	: "packages",
	    "type"	: "image",
	    "__children": union (union (packages, patterns), ignored)
    ];
    if (config["image_patternType"]:"" != "")
	ret["patternType"]	= config["image_patternType"]:"";
    return ret;
  }

  /**
   * which keys in config.xml are not unique
   */
  map non_unique_key	= $[
    "package"		: true,
    "opensusePattern"	: true,
    "ignore"		: true,
    "user"		: true,
    "source"		: true,
    "file"		: true, // for drivers section
  ];

  /**
   * convert YCP map (of internal type) to XML
   */
  string Map2XML (map descr, integer level) {

    string children	= "";
    string value	= "";
    string tab		= "";
    integer i		= 0;
    while (i < level) {
	i = i + 1;
	tab	= tab + "\t";
    }
    string key	= descr["__key"]:"";
    if (key == "") return "";
    string ret	= tab + "<" + key;
    foreach (string subkey, any val, (map<string,any>) descr, {
	if (subkey == "__key" || non_unique_key[subkey]:false) return;
	if (subkey == "__children" && is (val, list))
	    foreach (map chmap, (list<map>) val, {
		children	= children + "\n" + Map2XML (chmap, level + 1);
	    });
	else if (subkey == "__value")
	    value = sformat ("%1", val);
	else if (is (val, string))
	    ret	= sformat ("%1 %2=\"%3\"", ret, subkey, val);
    });
    if (non_unique_key[key]:false)
	return sformat ("%1/>", ret);
    if (value != "")
	ret = sformat ("%1>%2", ret, value);
    else
	ret	= ret + ">";
    if (children != "")
	ret =	 ret + children + "\n";
    ret	= sformat ("%1%2</%3>", ret, haskey (descr, "__value") ? "" : tab, key);
    return ret;
  }

  /**
   * import the data from given config.xml
   * @param directory where to look for config.xml
   * @ret map of imported data
   */
  global map<string,any> ReadConfigXML (string base_path) {

    map<string,any> ret	= $[];
    if (!FileUtils::Exists (base_path + "/config.xml"))
	return ret;

    map config	= (map) SCR::Read (.kiwi, base_path + "/config.xml");
    map<string,map> packages	= config["packages"]:$[];
    // rest parts of "packages" are saved in product-creator map
    ret["ignore"] = maplist (map p,
	(list<map>)packages["image","ignore"]:[], ``(p["name"]:""));
    // value of "arch" is currently ignored...
    foreach (string section, [ "boot", "xen" ], {
	ret[section + "_packages"]	= maplist (map p,
	    (list<map>)packages[section, "package"]:[], ``(p["name"]:""));
	ret[section + "_patterns"]	= maplist (map p,
	    (list<map>)packages[section,"opensusePattern"]:[],``(p["name"]:""));
	ret[section + "_ignore"]	= maplist (map p,
	    (list<map>)packages[section, "ignore"]:[], ``(p["name"]:""));
    });
    // list of packages and patterns is needed for import, not for new image
    ret["addons"] = maplist (map p,
	(list<map>)packages["image","opensusePattern"]:[], ``(p["name"]:""));
    ret["packages"] = maplist (map p,
	(list<map>)packages["image","package"]:[], ``(p["name"]:""));

    if (haskey (packages, "delete"))
    {
	ret["delete_packages"]	= maplist (map p,
	    (list<map>)packages["delete", "package"]:[], ``(p["name"]:""));
    }

    if (packages["image","patternType"]:"" != "")
	ret["image_patternType"]	= packages["image","patternType"]:"";
    if (packages["xen","disk"]:"" != "")
	ret["xen_disk"]	= packages["xen","disk"]:"";
    if (packages["xen","memory"]:"" != "")
	ret["xen_memory"]	= tointeger (packages["xen","memory"]:"512");
    foreach (string key, [ "author", "contact", "specification",
	"packagemanager", "version", "rpm-check-signatures", "rpm-force",
	"sizeunit", "type", "name", "repository", "defaultdestination",
	"schemeversion", "defaultroot", "inherit"],
    {
	if (config[key]:nil != nil)
	    ret[key]	= config[key]:nil;
    });
    if (haskey (config, "size"))
	ret["size"]	= tointeger (config["size"]:"2700");
    if (haskey (config, "defaultdestination"))
	ret["iso-directory"]	= config["defaultdestination"]:"";
    foreach (string user, map usermap, (map<string,map>) config["users"]:$[], {
	if (!haskey (ret, "users"))
	    ret["users"]     = $[];
	if (haskey (usermap, "group"))
	    ret["group"]	= usermap["group"]:"";
	ret["users",user]     = $[
	    "home"	: usermap["home"]:sformat ("/home/%1", user),
	    "pwd"	: user
	];
    });
    return ret;
  }

  /**
   * Write currect configuration to new config.xml
   */
  global boolean WriteConfigXML (map KiwiConfig, string task) {

    all_sources		= Pkg::SourceEditGet();

    tmp_dir		= Directory::tmpdir;
    chroot_dir		= tmp_dir + "/myphysical";
    if (KiwiConfig["defaultroot"]:"" != "")
    {
	chroot_dir	=
	    KiwiConfig["defaultroot"]:"" + "/" + KiwiConfig["name"]:"";
	KiwiConfig["defaultroot"]	= chroot_dir;
    }

    list packages_list	= [];
    list patterns_list	= [];
    list ignored_list	= [];
    list packages_boot_list	= [];
    list patterns_boot_list	= [];
    list ignored_boot_list	= [];

    list packages_xen_list	= [];
    list patterns_xen_list	= [];
    list ignored_xen_list	= [];

    foreach (string package, (list<string>) KiwiConfig["packages"]:[], {
	packages_list	= add (packages_list, $[
	    "__key"	: "package",
	    "name"	: package,
	]);
    });
    foreach (string pattern, (list<string>) KiwiConfig["addons"]:[], {
	patterns_list	= add (patterns_list, $[
	    "__key"	: "opensusePattern",
	    "name"	: pattern,
	]);
    });
    foreach (string package, (list<string>) KiwiConfig["ignore"]:[], {
	ignored_list	= add (ignored_list, $[
	    "__key"	: "ignore",
	    "name"	: package,
	]);
    });
    list<string> boot_packages	=
	KiwiConfig["boot_packages"]:["filesystem", "glibc-locale", "kernel-default", "devs" ];
    foreach (string package, boot_packages, {
	packages_boot_list	= add (packages_boot_list, $[
	    "__key"		: "package",
	    "name"		: package,
	]);
    });
    foreach (string ignore, KiwiConfig["boot_ignore"]:[], {
	ignored_boot_list	= add (ignored_boot_list, $[
	    "__key"		: "ignore",
	    "name"		: ignore,
	]);
    });


    foreach (string package, KiwiConfig["xen_packages"]:[], {
	packages_xen_list	= add (packages_xen_list, $[
	    "__key"		: "package",
	    "name"		: package,
	]);
    });
    foreach (string pattern, KiwiConfig["xen_patterns"]:[], {
	patterns_xen_list	= add (patterns_xen_list, $[
	    "__key"		: "pattern",
	    "name"		: pattern,
	]);
    });
    foreach (string ignore, KiwiConfig["xen_ignore"]:[], {
	ignored_xen_list	= add (ignored_xen_list, $[
	    "__key"		: "ignore",
	    "name"		: ignore,
	]);
    });

    list packages_delete_list	= maplist (string package,
	KiwiConfig["delete_packages"]:[], ``($[
	    "__key"		: "package",
	    "name"		: package,
	])
    );

    map preferences	= $[
	    "__key"	: "preferences",
	    "__children"	: [
		get_type_value (KiwiConfig, task),
		$[
		    "__key"	: "version",
		    "__value"	: KiwiConfig["version"]:"1",
		],
		$[
		    "__key"	: "size",
		    "unit"	: KiwiConfig["sizeunit"]:"M",
		    "__value"	: sformat ("%1", KiwiConfig["size"]:2700),
		],
		$[
		    "__key"	: "packagemanager",
		    "__value"   : KiwiConfig["packagemanager"]:default_packagemanager
		],
		$[
		    "__key"	: "rpm-check-signatures",
		    "__value"	: KiwiConfig["rpm-check-signatures"]:"False",
		],
		$[
		    "__key"	: "rpm-force",
		    "__value"	: KiwiConfig["rpm-force"]:"True",
		],
		$[
		    "__key"	: "defaultdestination",
		    "__value"	: KiwiConfig["iso-directory"]:"",
		],
	    ],
    ];
    if (KiwiConfig["defaultroot"]:"" != "")
    {
	preferences["__children"]	= add (preferences["__children"]:[], $[
		    "__key"	: "defaultroot",
		    "__value"	: KiwiConfig["defaultroot"]:"",
	]);
    }


    list write_list	= [ $[
      "__key"		: "image",
      "name"		: KiwiConfig["name"]:"",
      "schemeversion"	: KiwiConfig["schemeversion"]:"1.4",
      "__children"	: [
	$[
	    "__key"	: "description",
	    "type"	: "system",
	    "__children"	: [
		$[
		    "__key"	: "author",
		    "__value"	: KiwiConfig["author"]:"",
		],
		$[
		    "__key"	: "contact",
		    "__value"	: KiwiConfig["contact"]:"",
		],
		$[
		    "__key"	: "specification",
		    "__value"	: KiwiConfig["specification"]:"",
		],
	    ],
	],
	preferences,
      ],
    ]];
    if (KiwiConfig["inherit"]:"" != "")
	write_list[0,"inherit"]	= KiwiConfig["inherit"]:"";
    if (haskey (KiwiConfig, "users"))
    {
	write_list[0,"__children"] = add (write_list[0,"__children"]:[], $[
	    "__key"	: "users",
	    "group"	: KiwiConfig["group"]:"users",
	    "__children" :
		maplist (string user, map usermap, (map<string,map>) KiwiConfig["users"]:$[], ``(
		    $[
			"__key"	: "user",
			"name"	: user,
			"pwd"	: crypt_password (usermap["pwd"]:""),
			"home"	: usermap["home"]:"",
		    ]
		))
	]);
    }
    write_list[0,"__children"] = union (write_list[0,"__children"]:[],
	maplist (string source, (list<string>) KiwiConfig["sources"]:[],
	    ``(get_source_value (source, KiwiConfig))
	)
    );
    write_list[0,"__children"] = union (write_list[0,"__children"]:[], [
	get_image_packages (
	    KiwiConfig, packages_list, patterns_list, ignored_list),
	$[
	    "__key"	: "packages",
	    "type"	: "boot",
	    "__children": union (union (packages_boot_list, patterns_boot_list), ignored_boot_list)
	],
    ]);
    if (task == "xen")
    {
	write_list[0,"__children"] = add (write_list[0,"__children"]:[], $[
	    "__key"	: "packages",
	    "type"	: "xen",
	    // FIXME disk and memory not configurable
	    "disk"	: KiwiConfig["xen_disk"]:"/dev/sda",
	    "memory"	: sformat ("%1", KiwiConfig["xen_memory"]:512),
	    "__children": union (union (packages_xen_list, patterns_xen_list), ignored_xen_list)
	]);
    }

    if (packages_delete_list != [])
    {
	write_list[0,"__children"] = add (write_list[0,"__children"]:[], $[
	    "__key"	: "packages",
	    "type"	: "delete",
	    "__children": packages_delete_list
	]);
    }

    string write_string	= Map2XML (write_list[0]:$[], 0);
    config_dir	= tmp_dir + "/" + KiwiConfig["name"]:"";
    SCR::Execute (.target.mkdir, config_dir);
    SCR::Write (.target.string, config_dir + "/config.xml", write_string);
    foreach (string dir, ["root_dir", "config_dir"], {
	foreach (string val, KiwiConfig[dir]:[], {
	    string realdir	= config_dir + "/" + substring (dir, 0, search (dir, "_"));
	    boolean created	= false;
	    if (val != "" && FileUtils::Exists (val))
	    {
		if (!created && !FileUtils::Exists (realdir))
		{
		    SCR::Execute (.target.mkdir, realdir);
		    created	= true;
		}
		SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", val, realdir));
	    }
	});
    });
    foreach (string file, ["images.sh", "config.sh" ], {
	if (KiwiConfig[file]:"" != "")
	{
	    SCR::Write (.target.string, config_dir + "/" + file, KiwiConfig[file]:"");
	    SCR::Execute (.target.bash, "chmod +x " + config_dir + "/" + file);
	}
    });
    foreach (string file, KiwiConfig["import_files"]:[], {
	y2milestone ("copying %1 to %2", file,config_dir);
	SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", file,config_dir));
    });
    return true;
  }

  // run kiwi to finally create the live iso image
  global boolean PrepareAndCreate (string out_dir) {

    if (config_dir == "" || !FileUtils::Exists (config_dir))
	return false;
    if (!Package::Install ("kiwi"))
    {
	Report::Error (Message::CannotContinueWithoutPackagesInstalled ());
	return false;
    }

    if (FileUtils::Exists (chroot_dir))
    {
	y2milestone ("%1 directory is present, removing...", chroot_dir);
	SCR::Execute (.target.bash, sformat ("rm -rf %1", chroot_dir));
    }

    // construct the dialog
    UI::OpenDialog(`opt(`decorated), `HBox(`HSpacing(1.5),
    `VBox(
        `HSpacing(85),
	`VWeight (2, `VBox (
	    `VSpacing(0.5),
	    // label
	    `ReplacePoint (`id (`rpl), `Left (`Label(_("Preparing for Image Creation")))),
	    `VSpacing(0.5),
	    `LogView (`id (`log), "", 8, 0)
	)),
	`VWeight (1, `VBox (
	    `VSpacing(0.5),
	    `LogView (`id (`errlog), "", 8, 0),
	    `VSpacing(0.5),
	    `ReplacePoint (`id (`rp), `PushButton (`id(`cancel),`opt(`key_F9), Label::CancelButton ())),
	    `VSpacing(0.5)
	))
    ), `HSpacing(1.5)
    ));

    void update_output () {
        // read the output line from irw:
	list<string> out	= (list<string>)SCR::Read(.background.newout);
	foreach (string line, out, {
	    line	= String::Replace (line, "\r", "\n");
	    UI::ChangeWidget (`id(`log), `LastLine, line + "\n");
	});

	list<string> err = (list<string>) SCR::Read(.background.newerr);
	foreach (string line, err, {
	    line	= String::Replace (line, "\r", "\n");
	    UI::ChangeWidget (`id(`errlog), `LastLine, line + "\n");
	});
    }

    string cmd	= sformat ("ZYPP_READONLY_HACK=1 kiwi --root %1 --prepare %2 --logfile terminal", chroot_dir, config_dir);

    y2milestone ("calling '%1'", cmd);

    SCR::Execute (.background.run_output_err, cmd);

    symbol ret		= nil;
    boolean creating	= false;
    do
    {
	ret = (symbol) UI::PollInput();
        if ((boolean) SCR::Read(.background.output_open) &&
	    (integer) SCR::Read(.background.newlines)>0)
        {
	    update_output ();
        }
	else if (!(boolean)SCR::Read(.background.isrunning))
	{
	    update_output ();

	    integer status	= (integer) SCR::Read (.background.status);
y2internal ("status: %1", status);
	    if (status != 0)
	    {
		UI::ReplaceWidget (`id (`rp), `HBox (
		    // label (command result)
		    `Label (`opt (`boldFont), _("Image creation failed.")),
		    `PushButton (`id(`close), Label::CloseButton ())
		));
		ret	= (symbol) UI::UserInput ();
		break;
	    }
	    else if (!creating)
	    {
		creating	= true;
		SCR::Execute(.background.kill); // just to be sure...

		// now continue with creating
		UI::ChangeWidget (`id(`log), `LastLine, "\n");
		cmd	= sformat ("ZYPP_READONLY_HACK=1 kiwi --create %1 -d %2 --logfile terminal", chroot_dir, out_dir);
		y2milestone ("calling '%1'", cmd);
		// label
		UI::ReplaceWidget (`id (`rpl), `Left (`Label (_("Creating Image"))));
		SCR::Execute (.background.run_output_err, cmd);
		ret	= nil;
		continue;
	    }
	    else
	    {
		UI::ReplaceWidget (`id (`rp), `HBox (
		    // label (command result)
		    `Label (`opt (`boldFont), _("Image creation succeeded.")),
		    `PushButton (`id(`ok), Label::OKButton ())
		));
		ret	= (symbol) UI::UserInput ();
		break;
	    }
	}
	if (ret == `cancel)
	{
	    SCR::Execute(.background.kill);
	}
	sleep (100);
    } while (ret == nil);

    SCR::Execute(.background.kill);
    UI::CloseDialog ();
    return ret == `ok;
  }

  /**
   * save the image configuration to the kiwi images directory
   */
  global string SaveConfiguration (map KiwiConfig, string task) {
    if (config_dir == "" || !FileUtils::Exists (config_dir))
	return nil;
    if (!FileUtils::Exists (images_dir))
	SCR::Execute (.target.mkdir, images_dir);
    SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", config_dir, images_dir));
    return (images_dir + KiwiConfig["name"]:"");
  }

    /**
     * Import repositories from given kiwi image configuration
     * @patam Config configuration map, as read from config.xml
     * @param dir path to directory containing this config.xml
     */
    global map <integer,map> ImportImageRepositories (map Config, string dir) {

	current_repositories	= $[];
	integer	i	= 0;
	foreach (map repo, (list<map>) Config["repository"]:[], {
	    string source	= repo["source",0,"path"]:"";
	    if (source != "")
	    {
		string url	= "";
		if (substring (source, 0, 7) == "this://")
		{
		    string source_path = substring (source, 7);
		    source	= dir + "/" + source_path;
		}
		if (substring (source, 0, 1) == "/")
		    url	= "dir://";
		current_repositories	[i]	= $[
		    "url"	: url + source,
		    "plaindir"	: repo["type"]:"" == "rpm-dir",
		    "org"	: repo,
		];
		i	= i + 1;
	    }
	});
	return current_repositories;
    }

   /**
    * Initialize the list of current repositories
    */
   global map <integer,map> InitCurrentRepositories () {

	Pkg::SourceRestore ();
	integer	i	= 0;
	foreach (map source, Pkg::SourceEditGet (), {
	    integer srcid       = source["SrcId"]:-1;
	    map data = Pkg::SourceGeneralData (srcid);
	    string url	= data["url"]:"";
	    current_repositories[i]	= $[
		"url"       : url,
		"plaindir"  : data["type"]:"" == "Plaindir"
	    ];
	    i	= i + 1;
	});
	return current_repositories;
   }

  /**
   * Read the templates on which the images can be based
   */
  global boolean ReadImageTemplates () {

    string dirs = (string)SCR::Read(.sysconfig.product-creator.IMAGE_TEMPLATES);
    map name_version	= $[];
    foreach (string line, splitstring (dirs, "\t "), {
	if (line == "" || substring (line, 0, 1) == "#")
	    return;
	templates_dirs	= add (templates_dirs, line);
	if (!FileUtils::IsDirectory (line))
	{
	    y2warning ("%1 is not a directory", line);
	    return;
	}
	map out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1", line));
	foreach (string d, splitstring(out["stdout"]:"", "\n"), {
	    if (d == "") return;
	    map config	= Kiwi::ReadConfigXML (line + "/" + d);
	    // index by full path, there may be same names
	    // (templates could be provided by different vendors)
	    if (config != nil && config != $[])
	    {
		string name	= config["name"]:"";
		string ver	= config["version"]:"";
		if (name_version[name]:"" == ver)
		    y2warning ("template %1,%2 already imported", name, ver);
		else
		{
		    name_version[name]	= ver;
		    Templates[line + "/" + d]	= config;
		}
	    }
	});
    });
    return true;
  }

  /**
   * REad the confgiuration stuff for image creator
   */
  global boolean Read () {

    string dir =
	(string) SCR::Read (.sysconfig.product-creator.IMAGE_CONFIGURATIONS);
    if (dir != nil && dir != "")
	images_dir	= dir;
    supported_boot_images	=
	(string) SCR::Read (.sysconfig.product-creator.SUPPORTED_BOOT_IMAGES);
    if (supported_boot_images == nil)
	supported_boot_images	= "";
    return ReadImageTemplates ();
  }

}

